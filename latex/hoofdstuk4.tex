\chapter{Discussie}
\section{Algoritmes}
Het vorige hoofdstuk toont de resultaten van de verschillende algoritmes. RF en DT presteren duidelijk beter dan beide types van PA. DT presteert goed, maar is nog steeds bekend om het slecht omgaan met ruis en het overfitten. Aangezien het verschil in uitvoeringstijd tussen DT en RF minimaal is, is het altijd beter om een RF te gebruiken. Alhoewel in de test blijkt dat de grootte van het RF geen al te grote impact heeft op de uitvoeringstijd, kan dit mogelijk nog een probleem vormen door de beperkte rekenkracht van de Raspberry Pi. Het controleprogramma voor de fiets zal immers parallel lopen met de cadanscontroller. Gelukkig heeft de Raspberry Pi vier cores en is een RF makkelijk te parallelliseren (door het instellen van het aantal parallelle taken). Het maximaal aantal taken zal dus vier zijn, maar hoogstwaarschijnlijk zal dit lager zijn zodat het controleprogramma er niet onder lijdt.
\\\\
Voor een RF zijn volgende hyperparameters aangeraden:
\begin{gather*}
\text{RF \tab diepte=4 of 5, aantal bomen=10-20}
\end{gather*}
Een groot nadeel van RF is dat het niet goed om kan met ongeziene omstandigheden. Bijvoorbeeld als het algoritme van niets of weinig data begint, kan het niet uit de reeds geziene data een goede voorspelling maken (t.o.v. lineaire regressie voor een simpel lineair probleem). Alvorens dit algoritme op de fiets getest wordt, zou er al een standaard model ingesteld moeten worden dat dan aangepast wordt door de fietser. Een andere, betere manier wordt hier voorgesteld. In plaats van de exacte cadans te voorspellen van de fietser, kan er een verschil voorspeld worden met een standaard cadans, bijvoorbeeld 70 rpm. Wanneer het model nog niets geleerd heeft, zal de cadanscontroller altijd een cadans voorspellen van 70 rpm. Als de fietser de cadans aanpast, dan moet het algoritme het verschil voorspellen tussen de standaard cadans en de gewenste cadans. Het model zal dus bijvoorbeeld een zeven kunnen voorspellen waardoor de aangeboden cadans 70+7=77 is.
\\\\
De huidige implementatie van een RF, geïmplementeerd in de scikit-learn bibliotheek, doet niet aan lokale regressie in de bladeren. In plaats daarvan bevatten de bladeren een gewoon getal. Mogelijk kan lokale regressie in de bladeren een betere prestatie leveren.
\section{Waarheid}
In de verschillende tests werd het fietsersmodel altijd als waarheid (\textit{ground truth}) gezien. Dit kan echter niet gebruikt worden, aangezien dit ongekend is. Als de fietser een update wil doen, dan weet het algoritme niet hoe hard het moet aanpassen. Als de fietser sneller wil trappen, is het dan twee rpm sneller of vijf? Dit is in deze thesis niet onderzocht, maar vormt nog een potentieel probleem in het succes van de real-time cadansaanpassing in een automatische fiets transmissie.
\section{Conceptuele drift}
In sectie 3.4 werden de resultaten van twee algoritmes, sliding window en biased reservoir sampling, getoond. In beide gevallen moest er minstens drie keer zoveel geleerd worden om het nieuwe concept te leren, wat toch wel een groot verschil is met het beginnen vanaf nul. Deze technieken doen het alleszins wel beter dan technieken zonder “vergeet” algoritme. Het voornaamste probleem hier is dat mensen die de fiets tweedehands kopen of als leen-, familiefiets gebruiken, een slechtere fietservaring zullen hebben dan mensen die de fiets nieuw kopen en alleen zelf gebruiken. Als de fiets als familiefiets wordt gebruikt, is het misschien nuttig om een conceptueel drift mechanisme te implementeren, zoals beschreven in 2.11.2 (tabel \ref{tab:voor- en nadelen van variabele sliding window}), dat gebruik maakt van een change detector en kan wisselen tussen getrainde modellen. Een familiefiets zal slechts gebruikt worden door enkele mensen. Een leenfiets daarentegen bereikt een veel groter publiek. Hier kan een reset functionaliteit nuttig zijn.
